{"version":3,"file":"cli.js","mappings":"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G;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAA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","sources":["webpack://seqparse/external node-commonjs \"fs\"","webpack://seqparse/external commonjs \"pino\"","webpack://seqparse/external commonjs \"pino-pretty\"","webpack://seqparse/./src/index.ts","webpack://seqparse/./src/fetchFile.ts","webpack://seqparse/external commonjs \"node-fetch\"","webpack://seqparse/./src/parseFile.ts","webpack://seqparse/external node-commonjs \"path\"","webpack://seqparse/./src/parsers/benchling.ts","webpack://seqparse/./src/utils.ts","webpack://seqparse/./src/parsers/biobrick.ts","webpack://seqparse/external commonjs \"xml2js\"","webpack://seqparse/./src/parsers/fasta.ts","webpack://seqparse/./src/parsers/genbank.ts","webpack://seqparse/./src/parsers/jbei.ts","webpack://seqparse/./src/parsers/sbol.ts","webpack://seqparse/./src/parsers/sbol.v1.ts","webpack://seqparse/./src/parsers/sbol.v2.ts","webpack://seqparse/./src/parsers/seqbuilder.ts","webpack://seqparse/./src/parsers/snapgene.ts","webpack://seqparse/webpack/bootstrap","webpack://seqparse/./src/cli.ts"],"sourcesContent":["module.exports = require(\"fs\");","module.exports = require(\"pino\");","module.exports = require(\"pino-pretty\");","import fetchFile, { isAccession } from \"./fetchFile\";\nimport parseFile from \"./parseFile\";\n\n/** Seq is a single parsed sequence from a file or accession. */\nexport interface Seq {\n  /** annotations of the sequence */\n  annotations: Annotation[];\n  /** name of the sequence */\n  name: string;\n  /** the sequence */\n  seq: string;\n  /** type of sequence. Inferred from the seq's symbols */\n  type: \"dna\" | \"rna\" | \"aa\" | \"unknown\";\n}\n\n/** Annotation is a single feature/annotation parsed from a sequence file. */\nexport interface Annotation {\n  /** color of the annotation if set */\n  color?: string;\n  /** 1 if forward, 0 if no direction, -1 if in reverse direction */\n  direction?: number;\n  /** end of the annotation, 0-based */\n  end: number;\n  /** name of the annotation */\n  name: string;\n  /** start of the annotation, 0-based */\n  start: number;\n  /** type field if set on the annotation */\n  type?: string;\n}\n\n/** Options to parse sequence files. */\nexport interface ParseOptions {\n  /**\n   * Whether to use cors-anywhere to circumvent iGEM's web server having a bad configuration.\n   */\n  cors?: boolean;\n\n  /** name of the source file */\n  fileName?: string;\n\n  /**\n   * Source of the file (ArrayBuffer). This is necessary for SnapGene.\n   *\n   * Eg after a read from FileReader.readAsArrayBuffer() in a browser:\n   * https://developer.mozilla.org/en-US/docs/Web/API/FileReader/readAsArrayBuffer\n   */\n  source?: ArrayBuffer;\n}\n\n/* Parse a sequence file. Or download a sequence with an Accession ID. */\nexport default async (input: string, options?: ParseOptions): Promise<Seq> => {\n  if (!options?.fileName && isAccession(input)) {\n    return await fetchFile(input, options);\n  }\n  return (await parseFile(input, options))[0];\n};\n","import fetch, { Response } from \"node-fetch\";\n\nimport { ParseOptions, Seq } from \".\";\nimport parseFile from \"./parseFile\";\n\n/**\n * Get a remote sequence from NCBI or the iGEM registry.\n */\nexport default async (accession: string, options?: ParseOptions): Promise<Seq> => {\n  // The user doesn't specify the target registry, so we have to infer it from the passed accession: iGEM or NCBI\n  let url = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=nuccore&id=${accession.trim()}&rettype=gbwithparts&retmode=text`;\n  if (accession.startsWith(\"BB\")) {\n    // it's a BioBrick... target the iGEM repo\n    if ((typeof window !== \"undefined\" && typeof process === \"undefined\") || options?.cors) {\n      // use this hack to get around a no-CORS setting on iGEM webserver, pending fix on their side\n      url = `https://cors-anywhere.herokuapp.com/http://parts.igem.org/cgi/xml/part.cgi?part=${accession.trim()}`;\n    } else {\n      url = `http://parts.igem.org/cgi/xml/part.cgi?part=${accession.trim()}`;\n    }\n  }\n\n  // Request the XML from the webserver\n  let body = \"\";\n  let response: Response;\n  try {\n    response = await fetch(url);\n    body = await response.text();\n  } catch (err) {\n    throw new Error(`Failed to get part: accession=${accession} url=${url} err=${err}`);\n  }\n  if (!response.ok || !body.length) {\n    throw new Error(`Failed to get part, no body returned: accession=${accession} url=${url}`);\n  }\n\n  return (await parseFile(body))[0];\n};\n\n/** returns whether the passed ID is an accession in iGEM or NCBI */\nexport const isAccession = (accession: string): boolean => {\n  if (accession.startsWith(\"BB\")) {\n    return true; // biobrick\n  }\n  if (accession.length < 14 && accession.match(/^[a-z0-9_\\-.]+$/i)) {\n    return true;\n  }\n  return false;\n};\n","module.exports = require(\"node-fetch\");","import { sep } from \"path\";\n\nimport { ParseOptions, Seq } from \".\";\nimport parseBenchling from \"./parsers/benchling\";\nimport parseBioBrick from \"./parsers/biobrick\";\nimport parseFasta from \"./parsers/fasta\";\nimport parseGenbank from \"./parsers/genbank\";\nimport parseJbei from \"./parsers/jbei\";\nimport parseSbol from \"./parsers/sbol\";\nimport parseSeqBuilder from \"./parsers/seqbuilder\";\nimport parseSnapgene from \"./parsers/snapgene\";\nimport { complement, guessType } from \"./utils\";\n\n/**\n * parseFile converts the contents of a sequence file to a an array of Seq\n */\nexport default async (file: string, opts?: ParseOptions): Promise<Seq[]> => {\n  const fileName = opts?.fileName || \"\";\n  const sourceName = fileName.split(sep).pop() || fileName;\n\n  if (!file) {\n    throw Error(\"cannot parse null or empty string\");\n  }\n\n  // this is a check for an edge case, where the user uploads come kind\n  // of file that's full of bps but doesn't fit into a defined type\n  const firstLine = file.substring(0, file.search(\"\\n\"));\n  const dnaCharLength = firstLine.replace(/[^atcgATCG]/, \"\").length;\n  const dnaOnlyFile = dnaCharLength / firstLine.length > 0.8; // is it >80% dna?\n  const name = fileName && sourceName ? sourceName.substring(0, sourceName.search(\"\\\\.\")) : \"Untitled\";\n\n  // another edge case check for whether the seq is a JSON seq from Benchling\n  // just a heuristic that says 1) yes it can be parsed 2) it contains a list of\n  // fields that are common to Benchling files\n  let isBenchling = false;\n  try {\n    const benchlingJSON = JSON.parse(file); // will err out if not JSON\n    if ([\"bases\", \"annotations\", \"primers\"].every(k => typeof benchlingJSON[k] !== \"undefined\")) {\n      isBenchling = true;\n    }\n  } catch (ex) {\n    // expected\n  }\n\n  const prefix = file.substring(0, 200);\n  let seqs: Seq[];\n  switch (true) {\n    // JBEI\n    case prefix.includes(':seq=\"http://jbei.org/sequence\"'):\n    case file.startsWith(\"<seq:seq\"):\n      seqs = await parseJbei(file);\n      break;\n\n    // FASTA\n    case file.startsWith(\">\"):\n    case file.startsWith(\";\"):\n    case fileName.endsWith(\".seq\"):\n    case fileName.endsWith(\".fa\"):\n    case fileName.endsWith(\".fas\"):\n    case fileName.endsWith(\".fasta\"):\n      seqs = await parseFasta(file, fileName);\n      break;\n\n    // Genbank\n    case file.includes(\"LOCUS\") && file.includes(\"ORIGIN\"):\n    case fileName.endsWith(\".gb\"):\n    case fileName.endsWith(\".gbk\"):\n    case fileName.endsWith(\".genbank\"):\n    case fileName.endsWith(\".ape\"):\n      seqs = await parseGenbank(file, fileName);\n      break;\n\n    // SnapGene\n    case fileName.endsWith(\".dna\"):\n      seqs = await parseSnapgene(opts);\n      break;\n\n    // SeqBuilder\n    case prefix.includes(\"Written by SeqBuilder\"):\n    case fileName.endsWith(\".sbd\"):\n      seqs = await parseSeqBuilder(file, fileName);\n      break;\n\n    // BioBrick XML\n    case prefix.includes(\"Parts from the iGEM\"):\n    case prefix.includes(\"<part_list>\"):\n      seqs = await parseBioBrick(file);\n      break;\n\n    // Benchling JSON\n    case isBenchling:\n      seqs = await parseBenchling(file);\n      break;\n\n    // SBOL\n    case prefix.includes(\"RDF\"):\n      seqs = await parseSbol(file, fileName);\n      break;\n\n    // a DNA text file without an official formatting\n    case dnaOnlyFile: {\n      const { seq } = complement(file);\n      seqs = [{ annotations: [], name, seq, type: guessType(seq) }];\n      break;\n    }\n\n    default:\n      throw Error(`${fileName} File type not recognized: ${file}`);\n  }\n\n  // bit of clean up to: only return the fields in a Seq and reorder to match expectations.\n  return seqs.map(p => ({\n    annotations: p.annotations\n      .sort((a, b) => a.start - b.start || a.end - b.end)\n      .map(a => ({\n        color: a.color,\n        direction: a.direction,\n        end: a.end,\n        name: a.name,\n        start: a.start,\n        type: a.type,\n      })),\n    name: p.name,\n    seq: p.seq,\n    type: p.type,\n  }));\n};\n","module.exports = require(\"path\");","import { Seq } from \"..\";\nimport { complement, guessType, parseDirection } from \"../utils\";\n\n/**\n * Benchling format is just JSON. It's virtually the same format.\n */\nexport default async (text: string): Promise<Seq[]> => {\n  const partJSON = JSON.parse(text);\n  const { seq } = complement(partJSON.bases);\n\n  // throw an error if the sequence is empty\n  if (seq.length < 1) {\n    return Promise.reject(new Error(\"Invalid Benchling part: empty sequence\"));\n  }\n\n  return [\n    {\n      annotations: partJSON.annotations.map(a => ({\n        ...a,\n        direction: parseDirection(a.strand),\n      })),\n      name: partJSON.name || partJSON._id,\n      seq: seq,\n      type: guessType(seq),\n    },\n  ];\n};\n","// from http://arep.med.harvard.edu/labgc/adnan/projects/Utilities/revcomp.html\nconst comp = {\n  A: \"T\",\n  B: \"V\",\n  C: \"G\",\n  D: \"H\",\n  G: \"C\",\n  H: \"D\",\n  K: \"M\",\n  M: \"K\",\n  N: \"N\",\n  R: \"Y\",\n  S: \"S\",\n  T: \"A\",\n  U: \"A\",\n  V: \"B\",\n  W: \"W\",\n  X: \"X\",\n  Y: \"R\",\n  a: \"t\",\n  b: \"v\",\n  c: \"g\",\n  d: \"h\",\n  g: \"c\",\n  h: \"d\",\n  k: \"m\",\n  m: \"k\",\n  n: \"n\",\n  r: \"y\",\n  s: \"s\",\n  t: \"a\",\n  u: \"a\",\n  v: \"b\",\n  w: \"w\",\n  x: \"x\",\n  y: \"r\",\n};\n\n/**\n * Return the filtered sequence and its complement if its an empty string, return the same for both.\n */\nexport const complement = (origSeq: string): { compSeq: string; seq: string } => {\n  if (!origSeq) {\n    return { compSeq: \"\", seq: \"\" };\n  }\n\n  // filter out unrecognized basepairs and build up the complement\n  let seq = \"\";\n  let compSeq = \"\";\n  for (let i = 0, origLength = origSeq.length; i < origLength; i += 1) {\n    if (comp[origSeq[i]]) {\n      seq += origSeq[i];\n      compSeq += comp[origSeq[i]];\n    }\n  }\n  return { compSeq, seq };\n};\n\n/**\n * Return the reverse complement of a DNA sequence\n */\nexport const reverseComplement = (inputSeq: string): string => {\n  const { compSeq } = complement(inputSeq);\n  return compSeq.split(\"\").reverse().join(\"\");\n};\n\nexport const firstElement = (arr: any) => {\n  if (!Array.isArray(arr)) return undefined;\n  return arr[0];\n};\n\nconst fwd = new Set([\"FWD\", \"fwd\", \"FORWARD\", \"forward\", \"FOR\", \"for\", \"TOP\", \"top\", \"1\", 1]);\nconst rev = new Set([\"REV\", \"rev\", \"REVERSE\", \"reverse\", \"BOTTOM\", \"bottom\", \"-1\", -1]);\n\n/**\n * Parse the user defined direction, estimate the direction of the element\n *\n * ```js\n * parseDirection(\"FWD\") => 1\n * parseDirection(\"FORWARD\") => 1\n * ```\n */\nexport const parseDirection = (direction: number | string | undefined): -1 | 0 | 1 => {\n  if (!direction) {\n    return 0;\n  }\n  if (fwd.has(direction)) {\n    return 1;\n  }\n  if (rev.has(direction)) {\n    return -1;\n  }\n  return 0;\n};\n\n/**\n * mapping the 64 standard codons to amino acids\n * no synth AA's\n *\n * adapted from: \"https://github.com/keithwhor/NtSeq/blob/master/lib/nt.js\n */\nconst codon2AA = {\n  AAA: \"K\",\n  AAC: \"N\",\n  AAG: \"K\",\n  AAT: \"N\",\n  ACA: \"T\",\n  ACC: \"T\",\n  ACG: \"T\",\n  ACT: \"T\",\n  AGA: \"R\",\n  AGC: \"S\",\n  AGG: \"R\",\n  AGT: \"S\",\n  ATA: \"I\",\n  ATC: \"I\",\n  ATG: \"M\",\n  ATT: \"I\",\n  CAA: \"Q\",\n  CAC: \"H\",\n  CAG: \"Q\",\n  CAT: \"H\",\n  CCA: \"P\",\n  CCC: \"P\",\n  CCG: \"P\",\n  CCT: \"P\",\n  CGA: \"R\",\n  CGC: \"R\",\n  CGG: \"R\",\n  CGT: \"R\",\n  CTA: \"L\",\n  CTC: \"L\",\n  CTG: \"L\",\n  CTT: \"L\",\n  GAA: \"E\",\n  GAC: \"D\",\n  GAG: \"E\",\n  GAT: \"D\",\n  GCA: \"A\",\n  GCC: \"A\",\n  GCG: \"A\",\n  GCT: \"A\",\n  GGA: \"G\",\n  GGC: \"G\",\n  GGG: \"G\",\n  GGT: \"G\",\n  GTA: \"V\",\n  GTC: \"V\",\n  GTG: \"V\",\n  GTT: \"V\",\n  TAA: \"*\",\n  TAC: \"Y\",\n  TAG: \"*\",\n  TAT: \"Y\",\n  TCA: \"S\",\n  TCC: \"S\",\n  TCG: \"S\",\n  TCT: \"S\",\n  TGA: \"*\",\n  TGC: \"C\",\n  TGG: \"W\",\n  TGT: \"C\",\n  TTA: \"L\",\n  TTC: \"F\",\n  TTG: \"L\",\n  TTT: \"F\",\n};\n\nconst aminoAcids = Array.from(new Set(Object.values(codon2AA)).values()).join(\"\");\nconst aminoAcidRegex = new RegExp(`^[${aminoAcids}]+$`, \"i\");\n\n/** Infer the type of a sequence. This only allows a couple wildcard characters so may be overly strict. */\nexport const guessType = (seq: string): \"dna\" | \"rna\" | \"aa\" | \"unknown\" => {\n  if (/^[atgcn.]+$/i.test(seq)) {\n    return \"dna\";\n  } else if (/^[augcn.]+$/i.test(seq)) {\n    return \"rna\";\n  } else if (aminoAcidRegex.test(seq)) {\n    return \"aa\";\n  }\n  return \"unknown\";\n};\n","import * as xml2js from \"xml2js\";\n\nimport { Seq } from \"..\";\nimport { complement, firstElement, guessType, parseDirection } from \"../utils\";\n\n/**\n * Parse a BioBrick in XML format to Seq[]\n *\n * Eg: https://parts.igem.org/cgi/xml/part.cgi?part=BBa_J23100\n */\nexport default async (file: string): Promise<Seq[]> =>\n  new Promise((resolve, reject) => {\n    const bail = (err: string) => reject(new Error(`Failed on BioBrick: ${err}`));\n\n    // by default, all nodes are pushed to arrays, even if just a single child element\n    // is present in the XML\n    xml2js.parseString(file, {}, (err, response) => {\n      if (err) bail(`Failed to parse XML: ${err}`);\n\n      // get the first part\n      let part = firstElement(response.rsbpml.part_list);\n      if (!part || !part.part) bail(\"No part seen in part_list\");\n\n      // part is also an array... xml...\n      part = firstElement(part.part);\n      if (!part) bail(\"No part seen in part_list\");\n\n      // extract the useful fields\n      const { features: featureArray, part_name, sequences } = part;\n\n      // go another level...\n      const seq_data = firstElement(sequences);\n      if (!seq_data || !seq_data.seq_data) bail(\"No seq_data\");\n\n      let seq = firstElement(seq_data.seq_data);\n      const name = firstElement(part_name);\n\n      // go another level to get features...\n      let features = firstElement(featureArray);\n      if (features && \"feature\" in features) {\n        features = features.feature;\n      } else {\n        features = [];\n      }\n\n      // parse the iGEM annotations\n      const annotations = features\n        .map(f => {\n          if (!f) return null;\n\n          const { direction, endpos, startpos, type } = f;\n\n          return {\n            direction: parseDirection(direction[0]),\n            end: +endpos[0] || 0,\n            name: `${direction[0]}-${startpos[0]}`,\n            start: +startpos[0] || 0,\n            type: type[0] || undefined,\n          };\n        })\n        .filter(a => a);\n\n      ({ seq } = complement(seq));\n      resolve([\n        {\n          annotations: annotations,\n          name,\n          seq,\n          type: guessType(seq),\n        },\n      ]);\n    });\n  });\n","module.exports = require(\"xml2js\");","import { Seq } from \"..\";\nimport { guessType } from \"../utils\";\n\nexport default async (text: string, fileName: string): Promise<Seq[]> => {\n  // partFactory returns a negative \"circular\" prop, we assume they're all linear\n  if (text.trim().startsWith(\">\")) {\n    return text\n      .split(\">\") // split up if it's a multi-seq FASTA file\n      .map(t => {\n        // this starts at the end of the first line, grabs all other characters,\n        // and removes any newlines (leaving only the original sequence)\n        // sequence \"cleaning\" happens in complement (we don't support bps other than\n        // the most common right now)\n        const seq = t.substr(t.indexOf(\"\\n\"), t.length).replace(/\\s/g, \"\");\n\n        // the first line contains the name, though there's lots of variability around\n        // the information on this line...\n        // >MCHU - Calmodulin - Human, rabbit, bovine, rat, and chicken\n        const name = t.substring(0, t.search(/\\n|\\|/)).replace(/\\//g, \"\");\n\n        return {\n          annotations: [],\n          name,\n          seq,\n          type: guessType(seq),\n        };\n      })\n      .filter(p => p.name && p.seq);\n  }\n\n  if (text.trim().startsWith(\";\")) {\n    // it's an old-school style FASTA that's punctuated with semi-colons\n    // ;my|NAME\n    // ;my comment\n    // actGacgata\n    const name = text.substring(0, text.search(/\\n|\\|/)).replace(/\\//g, \"\");\n    const newlineBeforeSeq = text.indexOf(\"\\n\", text.lastIndexOf(\";\"));\n    const seq = text.substring(newlineBeforeSeq, text.length);\n    return [\n      {\n        annotations: [],\n        name,\n        seq,\n        type: guessType(seq),\n      },\n    ];\n  }\n\n  // assume that it's a no name FASTA. Ie it's just a file with dna and no header\n  // try and get the name from the fileName\n  const lastChar = fileName.lastIndexOf(\".\") || fileName.length;\n  const name = fileName.substring(0, lastChar) || \"Untitled\";\n  const seq = text;\n  return [\n    {\n      annotations: [],\n      name,\n      seq,\n      type: guessType(seq),\n    },\n  ];\n};\n","import { Annotation } from \"..\";\nimport { complement, guessType } from \"../utils\";\n\n// a list of recognized types that would constitute an annotation name\nconst tagNameSet = new Set([\"gene\", \"product\", \"note\", \"db_xref\", \"protein_id\", \"label\", \"lab_host\", \"locus_tag\"]);\n\n// a list of tags that could represent colors\nconst tagColorSet = new Set([\"ApEinfo_fwdcolor\", \"ApEinfo_revcolor\", \"loom_color\"]);\n\n/**\n * takes in a string representation of a GenBank file and outputs our\n * part representation of it. an example of a Genbank file can be found\n * at ./parsers/Gebank, though there is significant variability to the\n * format\n *\n * another official example can be found at:\n * https://www.ncbi.nlm.nih.gov/Sitemap/samplerecord.html\n */\nexport default async (fileInput: string, fileName: string) =>\n  fileInput\n    .split(/\\/\\/\\s/g)\n    .filter(f => f.length > 5)\n    .map(file => {\n      // the first row contains the name of the part and its creation date\n      // LOCUS       SCU49845     5028 bp    DNA             PLN       21-JUN-1999\n      const HEADER_ROW = file.substring(file.indexOf(\"LOCUS\"), file.search(/\\\\n|\\n/));\n      const [, name] = HEADER_ROW.split(/\\s{2,}/g).filter(h => h);\n\n      // trying to avoid giving a stupid name like Exported which Snapgene has by default\n      // also, if there is not name in header, the seq length will be used as name, which should\n      // be corrected (Number.parseInt to check for this case) https://stackoverflow.com/a/175787/7541747\n      let parsedName = name;\n      if (\n        (parsedName === \"Exported\" && file.includes(\"SnapGene\")) || // stupid Snapgene name\n        Number.parseInt(parsedName, 10) // it thinks seq-length is the name\n      ) {\n        // first try and get the name from ACCESSION\n        let accessionName = false;\n        if (file.includes(\"ACCESSION\")) {\n          // this will be undefined is there is no\n          const accession = file\n            .substring(file.indexOf(\"ACCESSION\"), file.indexOf(\"\\n\", file.indexOf(\"ACCESSION\")))\n            .replace(\".\", \"\")\n            .split(/\\s{2,}/)\n            .filter(a => a !== \"ACCESSION\")\n            .pop();\n          if (accession) {\n            parsedName = accession;\n            accessionName = true;\n          }\n        }\n\n        // otherwise, revert to trying to get the part name from the file name\n        if (!accessionName && fileName) {\n          parsedName = fileName\n            .substring(0, Math.max(fileName.search(/\\n|\\||\\./), fileName.lastIndexOf(\".\")))\n            .replace(/\\/\\s/g, \"\");\n        } else if (!accessionName) {\n          parsedName = \"Unnamed\"; // give up\n        }\n      }\n\n      // the part sequence is contained in and after the line that begins with ORIGIN\n      // do this before annotations so we can calc seqlength\n      //\n      // ORIGIN\n      //    1 gatcctccat atacaacggt atctccacct caggtttaga tctcaacaac ggaaccattg\n      //    61 ccgacatgag acagttaggt atcgtcgaga gttacaagct aaaacgagca gtagtcagct\n      const SEQ_ROWS = file.substring(file.lastIndexOf(\"ORIGIN\") + \"ORIGIN\".length, file.length);\n      let seq = SEQ_ROWS.replace(/[^gatc]/gi, \"\");\n      ({ seq } = complement(seq)); // seq and compSeq\n\n      // the features are translated into annotations\n      // region is FEATURES thru ORIGIN\n      // FEATURES             Location/Qualifiers\n      //   source          1..5028\n      //                   /organism=\"Saccharomyces cerevisiae\"\n      //                   /db_xref=\"taxon:4932\"\n      //                   /chromosome=\"IX\"\n      //                   /map=\"9\"\n      //\n      // in the example above, source is the annotation \"type\" and name is \"taxon:4932\"\n      // because \"db_xref\" is a recognized name type\n      // the name depends on whether the tag type is in the reocgnized list of types\n      const annotations: Annotation[] = [];\n      const primers = [];\n      if (file.indexOf(\"FEATURES\")) {\n        const FEATURES_LINE = file.indexOf(\"FEATURES\");\n        const FEATURES_NEW_LINE = file.indexOf(\"\\n\", FEATURES_LINE);\n        let ORIGIN_LINE = file.lastIndexOf(\"ORIGIN\");\n\n        // some files have a contig file line that needs to parsed out/ shouldn't be included in\n        // the features parsing\n        if (file.includes(\"CONTIG\")) {\n          ORIGIN_LINE = Math.min(ORIGIN_LINE, file.indexOf(\"CONTIG\"));\n        }\n        const FEATURES_ROWS = file\n          .substring(FEATURES_NEW_LINE, ORIGIN_LINE)\n          .split(/\\n/)\n          .filter(r => r);\n\n        FEATURES_ROWS.forEach(r => {\n          // in the example above, the following converts it to ['source', '1..5028']\n          const currLine = r.split(/\\s{2,}/g).filter(l => l);\n          if (currLine.length > 1) {\n            // it's the beginning of a new feature/annotation\n            const [type, rangeString] = currLine;\n            const rangeRegex = /\\d+/g;\n            const direction = r.includes(\"complement\") ? -1 : 1;\n\n            // using the example above, this parses 1..5028 into 1 and 5028\n            let [start, end] = [0, 0];\n            const startSearch = rangeRegex.exec(rangeString);\n\n            if (startSearch) {\n              // the - 1 is because genbank is 1-based while we're 0\n              start = +startSearch[0] - (1 % seq.length);\n              // single bp annotations are a thing in Genbank:\n              // https://github.com/Lattice-Automation/seqviz/issues/117\n              end = (start + 1) % seq.length;\n              const endSearch = rangeRegex.exec(rangeString);\n              if (endSearch) {\n                end = +endSearch[0] % seq.length;\n              }\n            }\n\n            if (type !== \"source\") {\n              // create a new annotation around the properties in this line (type and range)\n              annotations.push({\n                direction,\n                // set in next block\n                end,\n                name: \"\",\n                start,\n                type,\n              });\n            }\n          } else if (currLine.length === 1) {\n            // it's a continuation of a prior feature/annotation\n            // any updates (to name or color) to the last annotation should affect\n            // the last annotation that's in the array\n            if (currLine[0].startsWith(\"/\")) {\n              let [tag] = currLine;\n              tag = tag.replace(/[/\"]/g, \"\"); // get rid of quotation marks and forward slaches\n              // should now look like ['organism', 'Saccharomyces cerevisiae']\n              const [tagName, tagValue] = tag.split(/=/);\n\n              // the two values that can be extracted are name or color\n              const lastAnn = annotations.length - 1;\n              if (tagNameSet.has(tagName.toLowerCase())) {\n                // the key is something we recognize as an annotation name\n                if (lastAnn >= 0 && !annotations[lastAnn].name) {\n                  annotations[lastAnn].name = tagValue.trim();\n                }\n              } else if (tagColorSet.has(tagName)) {\n                // the key is something we recognize as an annotation color\n                if (lastAnn > -1) {\n                  annotations[lastAnn].color = tagValue;\n                }\n              }\n            }\n          }\n        });\n      }\n\n      return {\n        annotations: annotations,\n        name: parsedName.trim() || fileName,\n        primers: primers,\n        seq: seq,\n        type: guessType(seq),\n      };\n    });\n","import * as xml2js from \"xml2js\";\n\nimport { Annotation, Seq } from \"..\";\nimport { complement, guessType } from \"../utils\";\n\n/**\n * Converts a JBEI file to a Seq\n *\n * https://j5.jbei.org/j5manual/pages/94.html\n */\nexport default async (JBEI: string): Promise<Seq[]> =>\n  new Promise((resolve, reject) => {\n    // weird edge case with directed quotation characters\n    const fileString = JBEI.replace(/|/g, '\"');\n\n    xml2js.parseString(\n      fileString,\n      {\n        attrkey: \"xml_tag\",\n        tagNameProcessors: [xml2js.processors.stripPrefix],\n        xmlns: true,\n      },\n      (err, parsedJBEI) => {\n        if (err) {\n          reject(new Error(`Failed to parse JBEI file: ${err}`));\n        }\n\n        // destructure the paramaeters from JBEI\n        const { seq } = parsedJBEI;\n        const { features, name, sequence } = seq;\n\n        // attempt to get the name out of the JBEI\n        let parsedName = \"Unnamed\";\n        if (name && name[0] && name[0]._) {\n          parsedName = name[0]._;\n        }\n\n        // attempt to get the sequence. fail if it's not findable\n        let parsedSeq = \"\";\n        if (sequence && sequence[0] && sequence[0]._) {\n          parsedSeq = sequence[0]._;\n        }\n        const { seq: parsedSeq2 } = complement(parsedSeq); // seq and compSeq\n        if (!parsedSeq2) return null;\n\n        // attempt to parse the JBEI annotations into our version of annotations\n        const annotations: Annotation[] = [];\n        if (features && features[0] && features[0].feature) {\n          features[0].feature.forEach(feature => {\n            if (!feature) return;\n\n            const { label = [{}], type = [{}], complement = [{}], location = [] } = feature;\n            if (location && location[0] && location[0].genbankStart && location[0].end) {\n              annotations.push({\n                direction: complement[0]._ === \"true\" ? -1 : 1,\n                // JBEI is 1-based\n                end: +location[0].end[0]._ || 0,\n                name: label[0]._ || \"Untitled\",\n                start: +location[0].genbankStart[0]._ - 1 || 0,\n                type: type[0]._ || \"N/A\",\n              });\n            }\n          });\n        }\n\n        resolve([\n          {\n            annotations: annotations,\n            name: parsedName,\n            seq: parsedSeq2,\n            type: guessType(parsedSeq2),\n          },\n        ]);\n      }\n    );\n  });\n","import { Seq } from \"..\";\nimport sbolV1 from \"./sbol.v1\";\nimport sbolV2 from \"./sbol.v2\";\n\n/**\n * takes in an SBOL file in v1 or v2 format, and parses to an array of parts\n * that match the Loom data model\n */\nexport default async (sbol: string, fileName: string): Promise<Seq[]> =>\n  sbol.includes(\"sbols.org/v1#\") ? sbolV1(sbol) : sbolV2(sbol, fileName);\n","import * as xml2js from \"xml2js\";\n\nimport { Annotation, Seq } from \"..\";\nimport { complement, guessType } from \"../utils\";\n\n/*\n  <sbol:Sequence rdf:about=\"https://synbiohub.cidarlab.org/public/Demo/A1_sequence/1\">\n    <sbol:persistentIdentity rdf:resource=\"https://synbiohub.cidarlab.org/public/Demo/A1_sequence\"/>\n    <sbol:displayId>A1_sequence</sbol:displayId>\n    <sbol:version>1</sbol:version>\n    <prov:wasDerivedFrom rdf:resource=\"https://github.com/CIDARLAB/cello/blob/master/resources/UCF/Eco1C1G1T0.UCF.json\"/>\n    <prov:wasGeneratedBy rdf:resource=\"https://synbiohub.cidarlab.org/public/Demo/cello2sbol/1\"/>\n    <dcterms:title>A1_sequence</dcterms:title>\n    <sbh:ownedBy rdf:resource=\"https://synbiohub.cidarlab.org/user/prash\"/>\n    <sbh:topLevel rdf:resource=\"https://synbiohub.cidarlab.org/public/Demo/A1_sequence/1\"/>\n    <sbol:elements>AATGTTCCCTAATAATCAGCAAAGAGGTTACTAG</sbol:elements>\n    <sbol:encoding rdf:resource=\"http://www.chem.qmul.ac.uk/iubmb/misc/naseq.html\"/>\n  </sbol:Sequence>\n*/\n\n/**\n * after getting a DnaComponent out of the SBOL document,\n * at either the root RDF level or from within a Collection/Annotation\n * heirarchy, convert that DnaComponent to a Seq\n */\nconst dnaComponentToPart = (DnaComponent, options) => {\n  const { file, strict = false } = options;\n  // destructure the paramaeters from DnaComponent\n  const { annotation, displayId, dnaSequence, name } = DnaComponent;\n\n  // attempt to get the name out of the SBOL\n  let parsedName = \"Unnamed\";\n  if (name && name[0] && name[0]._) {\n    parsedName = name[0]._;\n  } else if (displayId && displayId[0] && displayId[0]._) {\n    parsedName = displayId[0]._;\n  } else if (strict) {\n    // in this scenario, we're really scrapping to find parts, but shouldn't\n    // accept any that don't at least have some name and sequence information\n    return null;\n  }\n\n  // attempt to get the sequence. fail if it's not findable\n  let seq = \"\";\n  if (dnaSequence && dnaSequence[0] && dnaSequence[0].DnaSequence) {\n    const { DnaSequence } = dnaSequence[0];\n    if (\n      DnaSequence[0] &&\n      DnaSequence[0].nucleotides &&\n      DnaSequence[0].nucleotides[0] &&\n      DnaSequence[0].nucleotides[0]._\n    ) {\n      seq = DnaSequence[0].nucleotides[0]._;\n    }\n  }\n  const { compSeq: parsedCompSeq, seq: parsedSeq } = complement(seq); // seq and compSeq\n  if (!parsedSeq) return null;\n\n  // attempt to parse the SBOL annotations into our version of annotations\n  const annotations: Annotation[] = [];\n  if (annotation) {\n    annotation.forEach(({ SequenceAnnotation }) => {\n      if (!SequenceAnnotation || !SequenceAnnotation[0]) return;\n\n      const { bioStart = [{}], bioEnd = [{}], strand, subComponent } = SequenceAnnotation[0];\n      if (subComponent && subComponent[0] && subComponent[0].DnaComponent && subComponent[0].DnaComponent[0]) {\n        const { type: annType = [{}], displayId: annId = [{}], name: annName = [{}] } = subComponent[0].DnaComponent[0];\n\n        annotations.push({\n          // we're 0-based\n          direction: strand[0]._ === \"+\" ? 1 : -1,\n          // sbol is 1-based\n          end: bioEnd[0]._ || 0,\n          name: annName[0]._ || annId[0]._ || \"Untitled\",\n          start: bioStart[0]._ - 1 || 0,\n          type: annType[0]._ || \"N/A\",\n        });\n      }\n    });\n  }\n\n  // guess whether it's circular or not based on the presence of a word like vector.\n  // very ad hoc\n  const circular = file.search(/plasmid/i) > 0;\n\n  return {\n    annotations: annotations,\n    circular: circular,\n    compSeq: parsedCompSeq,\n    name: parsedName,\n    seq: parsedSeq,\n    type: guessType(seq),\n  };\n};\n\n/**\n * find all nodes that of the type Sequence, and convert those to parts \"Sequence\" -> Part\n *\n \n * this is not the standard format. see A1.xml\n */\nconst sequenceToPart = (Seq, file) => {\n  // get the name\n  const name = (Seq.displayId[0] && Seq.displayId[0]._) || (Seq.title[0] && Seq.title[0]._) || \"Unnamed\";\n\n  // get the sequence\n  const seqOrig = (Seq.elements[0] && Seq.elements[0]._) || \"\";\n\n  const { compSeq, seq } = complement(seqOrig);\n\n  // guess whether it's circular or not based on the presence of a word like vector.\n  // very ad hoc\n  const circular = file.search(/plasmid/i) > 0;\n\n  return { annotations: [], circular, compSeq, name, seq, type: guessType(seq) };\n};\n\n/**\n * find all the nodes within the SBOL JSON document that are keyed \"DnaComponent\"\n *\n * this is a last-resort scrapper that tries to find valid parts that aren't within a root\n * DnaComponent document or within a root Collection array\n */\nconst findDnaComponentNodes = (acc: Seq[], doc: any) => {\n  Object.keys(doc).forEach(k => {\n    if (k === \"DnaComponent\" && doc[k].length) acc.push(...doc[k]);\n    if (Array.isArray(doc[k])) {\n      doc[k].forEach(nestedNode => {\n        findDnaComponentNodes(acc, nestedNode);\n      });\n    }\n  });\n};\n\n/**\n * find all the nodes within the JSON document that are keyed \"Sequence\"\n *\n * this is another last-resort scrapper for trying to find valid parts\n */\nconst findSequenceNodes = (acc, doc) => {\n  Object.keys(doc).forEach(k => {\n    if (k === \"Sequence\" && doc[k].length) acc.push(...doc[k]);\n    if (Array.isArray(doc[k])) {\n      doc[k].forEach(nestedNode => {\n        findSequenceNodes(acc, nestedNode);\n      });\n    }\n  });\n};\n\n/**\n * takes an SBOL file, as a string, and converts it into our DB\n * representation of a part(s). an example of this type of file can be\n * found in ../examples/j5.SBOL.xml\n */\nexport default async (sbol: string): Promise<Seq[]> =>\n  new Promise((resolve, reject) => {\n    // it shouldn't take longer than this to parse the SBOL file\n    setTimeout(() => {\n      reject(new Error(\"Took to long to parse SBOL\"));\n    }, 2000);\n\n    // util reject function that will be triggered if any fields fail\n    const rejectSBOL = errType => reject(new Error(`Failed on SBOL file; ${errType}`));\n\n    // weird edge case with directed quotation characters\n    const fileString = sbol.replace(/|/g, '\"');\n\n    xml2js.parseString(\n      fileString,\n      {\n        attrkey: \"xml_tag\",\n        tagNameProcessors: [xml2js.processors.stripPrefix],\n        xmlns: true,\n      },\n      (err, parsedSBOL) => {\n        if (err) rejectSBOL(err);\n        let RDF = null;\n        if (parsedSBOL.RDF) ({ RDF } = parsedSBOL);\n        if (!RDF) reject(new Error(\"No root RDF document\"));\n\n        // @ts-expect-error ts-migrate(2339) FIXME: Property 'Collection' does not exist on type 'null... Remove this comment to see the full error message\n        const { Collection, DnaComponent } = RDF;\n        if (Collection && Collection.length) {\n          // it's a collection of DnaComponents, parse each to a part\n          const partList = [];\n          Collection.forEach(({ component }) => {\n            if (component && component.length) {\n              component.forEach(({ DnaComponent: nestedDnaComponent }) => {\n                partList.push(\n                  // @ts-expect-error ts-migrate(2345) FIXME: Argument of type '{ seq: string; compSeq: string; ... Remove this comment to see the full error message\n                  dnaComponentToPart(nestedDnaComponent[0], {\n                    file: sbol,\n                    strict: false,\n                  })\n                );\n              });\n            }\n          });\n\n          // check whether any parts were created from the collection\n          if (partList.length) resolve(partList);\n        } else if (DnaComponent && DnaComponent.length) {\n          // create a single part from the single one passed\n          const validPart = dnaComponentToPart(DnaComponent[0], {\n            file: sbol,\n            strict: false,\n          });\n          // it will be null if there isnt' any sequence information beneath it\n          if (validPart) resolve([validPart]);\n        }\n\n        // go on a fishing expedition for DnaComponents\n        // everything else has failed\n        // accumulate all that are \"valid\" (name + seq)\n        const dnaComponentAccumulator = [];\n        findDnaComponentNodes(dnaComponentAccumulator, RDF);\n\n        // @ts-ignore\n        const attemptedSeqs: Seq[] = dnaComponentAccumulator\n          .map(p =>\n            dnaComponentToPart(p, {\n              file: sbol,\n              strict: true,\n            })\n          )\n          .filter(p => !!p); // invalid parts will be null\n        if (attemptedSeqs.length) resolve(attemptedSeqs);\n\n        // go on another fishing expedition, but for Sequence nodes\n        const dnaSequenceAccumulator = [];\n        findSequenceNodes(dnaSequenceAccumulator, RDF);\n        const sequenceNodes = dnaSequenceAccumulator.map(p => sequenceToPart(p, sbol)).filter(p => p); // invalid parts will be null\n        if (sequenceNodes.length) resolve(sequenceNodes);\n\n        // neither a DnaComponent nor Collection was found anywhere in document\n        reject(new Error(\"no valid DnaComponent or Collection\"));\n      }\n    );\n  });\n","import * as xml2js from \"xml2js\";\n\nimport { Annotation, Seq } from \"..\";\nimport { complement, guessType } from \"../utils\";\n\n// get the first string/number child out of an array of possible null elements\nconst first = elArr => {\n  if (elArr && elArr[0]) {\n    if (elArr[0]._) {\n      return elArr[0]._;\n    }\n    return elArr[0];\n  }\n  return null;\n};\n\n/**\n * Converts an SBOL file to our Seq format.\n *\n * SBOL v2.0 schema definition can be found at: http://sbolstandard.org/wp-content/uploads/2016/06/SBOL-data-model-2.2.1.pdf\n * differs from SBOL v1.0 in that the ComponentDefinitions are like the root parts,\n * and the sequence and annotations are separated (they're no longer defined relationally\n * by nesting but, instead, by id) we only care about components that have sequence information\n */\nexport default async (sbol: string, fileName: string): Promise<Seq[]> =>\n  new Promise((resolve, reject) => {\n    // weird edge case with directed quotation characters\n    const fileString = sbol.replace(/|/g, '\"');\n\n    xml2js.parseString(\n      fileString,\n      {\n        attrkey: \"xml_tag\",\n        tagNameProcessors: [xml2js.processors.stripPrefix],\n        xmlns: true,\n      },\n      (err, parsedSBOL) => {\n        if (err) {\n          reject(new Error(`Failed to parse SBOL v2: ${err}`));\n        }\n\n        try {\n          const seqList = parseSBOL2(parsedSBOL, fileName);\n\n          if (seqList.length) {\n            resolve(seqList);\n          } else {\n            throw new Error(\"No Sequence info found\");\n          }\n        } catch (err) {\n          reject(`Failed to parse SBOL v2 file: ${err}`);\n        }\n      }\n    );\n  });\n\nconst parseSBOL2 = (parsedSBOL, fileName: string): Seq[] => {\n  let RDF = null;\n  if (parsedSBOL.RDF) {\n    ({ RDF } = parsedSBOL);\n  }\n\n  if (!RDF) {\n    throw new Error(\"No root RDF document\");\n  }\n\n  // check if anything is defined, return if not\n  const { ComponentDefinition, Sequence } = RDF;\n  if (!ComponentDefinition && !Sequence) {\n    throw new Error(\"Failed to parse SBOL v2: No ComponentDefinition or Sequence\");\n  }\n\n  // read thru the Sequence elements\n  const getSeq = (seqID?: string) => {\n    const seqElement = seqID\n      ? // @ts-ignore\n        Sequence.find(\n          s =>\n            (s.persistentIdentity &&\n              s.persistentIdentity.length &&\n              s.persistentIdentity[0].xml_tag[\"rdf:resource\"].value === seqID) ||\n            s.xml_tag[\"rdf:about\"].value === seqID\n        )\n      : first(Sequence);\n\n    if (seqElement && seqElement.elements) {\n      const { seq } = complement(first(seqElement.elements) || \"\");\n      return {\n        annotations: [],\n        name: first(seqElement.displayId),\n        seq,\n        type: guessType(seq),\n      };\n    }\n    return null;\n  };\n\n  // if it's a collection of DnaComponents, parse each to a part\n  const seqList: Seq[] = [];\n  // @ts-ignore\n  ComponentDefinition?.forEach((c, i) => {\n    // we're only making parts out of those with seq info\n    if (!c.sequence || !c.sequence.length) {\n      return;\n    }\n\n    const { displayId, sequence, sequenceAnnotation } = c;\n    const name = first(displayId) || `${fileName}_${i + 1}`;\n\n    const annotations: Annotation[] = [];\n    (sequenceAnnotation || []).forEach(({ SequenceAnnotation }) => {\n      const ann = SequenceAnnotation[0];\n      const annId = first(ann.displayId);\n      const { Range } = first(ann.location);\n\n      const range = first(Range);\n      if (range) {\n        annotations.push({\n          end: first(range.end) - 1,\n          name: annId,\n          start: first(range.start) - 1,\n        });\n      }\n    });\n\n    const seqID = first(sequence)?.xml_tag[\"rdf:resource\"]?.value;\n\n    const seq = getSeq(seqID);\n    if (seq) {\n      seqList.push({\n        annotations,\n        name,\n        seq: seq.seq,\n        type: seq.type,\n      });\n    }\n  });\n\n  // if it's a single sequence, just try and get the sequence from that alone\n  const seq = getSeq();\n  if (!seqList.length && seq) {\n    seqList.push(seq);\n  }\n  return seqList;\n};\n","import { Annotation } from \"..\";\nimport { complement, guessType } from \"../utils\";\n\n// a list of recognized types that would constitute an annotation name\nconst tagNameList = [\"gene\", \"product\", \"note\", \"db_xref\", \"protein_id\", \"label\", \"lab_host\"];\n\n// a list of tags that could represent colors\nconst tagColorList = [\"ApEinfo_fwdcolor\", \"ApEinfo_revcolor\", \"loom_color\"];\n\n/**\n * takes in a string representation of a SeqBuilder file and outputs our\n * part representation of it. an example of a SeqBuilder file can be found\n * at imports/io/examples/seqbuilder, though there may be variations to the\n * format\n */\nexport default async (fileInput: string, fileName: string) =>\n  fileInput.split(/\\/\\/\\s/g).map(file => {\n    // +++++SEQUENCE+++++//\n    // the part sequence comes after the line that specifies the seqbuilder version number\n    // @ts-ignore\n    const SEQ_ROWS = file\n      .substring(\n        file.search(/.*?written by seqbuilder .*?[0-9.]+[^actg]+/i) +\n          // @ts-ignore\n          file.match(/.*?written by seqbuilder .*?[0-9.]+[^actg]+/i)[0].length,\n        file.length\n      )\n      .match(/[actgyrwskmdvhbxn]+/gim)[0];\n\n    let seq = SEQ_ROWS;\n    ({ seq } = complement(seq)); // seq and compSeq\n    // there may be a genbank-like header row after the sequence\n    // LOCUS       SCU49845     5028 bp    DNA             PLN       21-JUN-1999\n    let parsedName = fileName.length > 0 ? fileName : \"Unnamed\";\n\n    if (~file.indexOf(\"LOCUS\")) {\n      const HEADER_ROW = file.substring(file.indexOf(\"LOCUS\"), file.search(/\\\\n|\\n/));\n      if (HEADER_ROW && HEADER_ROW.split(/\\s{2,}/g)) {\n        const [, name] = HEADER_ROW.split(/\\s{2,}/g).filter(h => h);\n        parsedName = name;\n      }\n    }\n    // Name setting logic ported from GenBank parser\n    if (\n      (parsedName === \"Exported\" && file.includes(\"SnapGene\")) || // stupid Snapgene name\n      Number.parseInt(parsedName, 10) // it thinks seq-length is the name\n    ) {\n      // first try and get the name from ACCESSION\n      let accessionName = false;\n      if (file.includes(\"ACCESSION\")) {\n        // this will be undefined is there is no\n        const accession = file\n          .substring(file.indexOf(\"ACCESSION\"), file.indexOf(\"\\n\", file.indexOf(\"ACCESSION\")))\n          .replace(\".\", \"\")\n          .split(/\\s{2,}/)\n          .filter(a => a !== \"ACCESSION\")\n          .pop();\n        if (accession) {\n          parsedName = accession;\n          accessionName = true;\n        }\n      }\n\n      // otherwise, revert to trying to get the part name from the file name\n      if (!accessionName && fileName) {\n        parsedName = fileName\n          .substring(0, Math.max(fileName.search(/\\n|\\||\\./), fileName.lastIndexOf(\".\")))\n          .replace(/\\/\\s/g, \"\");\n      } else if (!accessionName) {\n        parsedName = \"Unnamed\"; // give up\n      }\n    }\n\n    // +++++ANNOTATIONS+++++//\n    // the features are translated into annotations\n    // region is FEATURES thru ORIGIN\n    // FEATURES             Location/Qualifiers\n    //   source          1..5028\n    //                   /organism=\"Saccharomyces cerevisiae\"\n    //                   /db_xref=\"taxon:4932\"\n    //                   /chromosome=\"IX\"\n    //                   /map=\"9\"\n    //\n    // in the example above, source is the annotation \"type\" and name is \"taxon:4932\"\n    // because \"db_xref\" is a recognized name type\n    // the name depends on whether the tag type is in the reocgnized list of types\n    const annotations: Annotation[] = [];\n    if (file.indexOf(\"FEATURES\")) {\n      const FEATURES_LINE = file.indexOf(\"FEATURES\");\n      const FEATURES_NEW_LINE = file.indexOf(\"\\n\", FEATURES_LINE);\n      let ORIGIN_LINE = file.lastIndexOf(\"ORIGIN\");\n\n      // some files have a contig file line that needs to parsed out/ shouldn't be included in\n      // the features parsing\n      if (file.includes(\"CONTIG\")) {\n        ORIGIN_LINE = Math.min(ORIGIN_LINE, file.indexOf(\"CONTIG\"));\n      }\n      const FEATURES_ROWS = file\n        .substring(FEATURES_NEW_LINE, ORIGIN_LINE)\n        .split(/\\n/)\n        .filter(r => r);\n\n      FEATURES_ROWS.forEach(r => {\n        // in the example above, the following converts it to ['source', '1..5028']\n        const currLine = r.split(/\\s{2,}/g).filter(l => l);\n        if (currLine.length > 1) {\n          // it's the beginning of a new feature/annotation\n          const [type, rangeString] = currLine;\n          const rangeRegex = /\\d+/g;\n          const direction = r.includes(\"complement\") ? -1 : 1;\n\n          // using the example above, this parses 1..5028 into 1 and 5028\n          let [start, end] = [0, 0];\n          const startSearch = rangeRegex.exec(rangeString);\n\n          if (startSearch) {\n            // the - 1 is because genbank is 1-based while we're 0\n            start = +startSearch[0] - (1 % seq.length);\n            const endSearch = rangeRegex.exec(rangeString);\n            if (endSearch) {\n              end = +endSearch[0] % seq.length;\n            }\n          }\n\n          if (type !== \"source\") {\n            // source would just be an annotation for the entire sequence so remove\n            // create a new annotation around the properties in this line (type and range)\n            annotations.push({\n              direction,\n              end,\n              name: \"\",\n              start,\n              type,\n            });\n          }\n        } else if (currLine.length === 1) {\n          // it's a continuation of a prior feature/annotation\n          // any updates (to name or color) to the last annotation should affect\n          // the last annotation that's in the array\n          let [tag] = currLine;\n          tag = tag.replace(/[/\"]/g, \"\"); // get rid of quotation marks and forward slaches\n          // should now look like ['organism', 'Saccharomyces cerevisiae']\n          const [tagName, tagValue] = tag.split(/=/);\n\n          // the two values that can be extracted are name or color\n          const lastAnnIndex = annotations.length - 1;\n          if (tagNameList.includes(tagName)) {\n            // it's key value pair where the key is something we recognize as an annotation name\n            if (lastAnnIndex > -1 && !annotations[annotations.length - 1].name) {\n              // defensively check that there isn't already a defined annotation w/o a name\n              annotations[annotations.length - 1].name = tagValue.trim();\n            }\n          } else if (tagColorList.includes(tagName)) {\n            // it's key value pair where the key is something we recognize as an annotation color\n            if (lastAnnIndex > -1) {\n              // defensively check that there's already been a defined annotation\n              annotations[annotations.length - 1].color = tagValue;\n            }\n          }\n        }\n      });\n    }\n\n    return {\n      annotations: annotations,\n      name: parsedName.trim() || fileName,\n      seq: seq,\n      type: guessType(seq),\n    };\n  });\n","import { sep } from \"path\";\nimport * as xml2js from \"xml2js\";\n\nimport { Annotation, ParseOptions, Seq } from \"..\";\nimport { guessType, parseDirection } from \"../utils\";\n\n/**\n * Parse a Snapgene file to Seq[]\n *\n * this is adapted from https://github.com/TeselaGen/ve-sequence-parsers/blob/master/src/parsers/snapgeneToJson.js\n * which was adapted from https://github.com/IsaacLuo/SnapGeneFileReader/blob/master/snapgene_reader/snapgene_reader.py\n */\nexport default async (options?: ParseOptions): Promise<Seq[]> => {\n  if (!options || !options.source) {\n    throw new Error(\"Failed to parse SnapGene file. No valid file input\");\n  }\n\n  const fileName = options?.fileName || \"\";\n  const seq = {\n    annotations: [] as Annotation[],\n    circular: false,\n    name: \"\",\n    seq: \"\",\n    type: \"unknown\",\n  };\n\n  const buffer = Buffer.from(options.source);\n\n  // Accumulate an offset from the start as we read through the file\n  let offset = 0;\n\n  // Read a buffer from the buffer\n  const read = (size: number) => {\n    const start = offset;\n    offset += size;\n    return buffer.subarray(start, offset);\n  };\n\n  // Read from buffer and decode as string\n  const readEnc = (size: number, fmt: BufferEncoding) => read(size).toString(fmt);\n\n  // Read the first byte\n  read(1);\n\n  // Read document properties\n  const length = read(4).readUInt32BE();\n  const title = readEnc(8, \"ascii\");\n  if (length !== 14 || title !== \"SnapGene\") {\n    throw new Error(`Wrong format for a SnapGene file: length=${length} title=${title}`);\n  }\n\n  read(2); // isDNA\n  read(2); // exportVersion\n  read(2); // importVersion\n\n  /* eslint-disable no-await-in-loop */\n  // READ THE WHOLE FILE, BLOCK BY BLOCK, UNTIL THE END\n  while (offset < buffer.length) {\n    // next_byte table\n    // 0: dna sequence\n    // 1: compressed DNA\n    // 2: unknown\n    // 3: unknown\n    // 5: primers\n    // 6: notes\n    // 7: history tree\n    // 8: additional sequence properties segment\n    // 9: file Description\n    // 10: features\n    // 11: history node\n    // 13: unknown\n    // 16: alignable sequence\n    // 17: alignable sequence\n    // 18: sequence trace\n    // 19: Uracil Positions\n    // 20: custom DNA colors\n\n    const nextByte = read(1);\n    const blockSize = read(4).readUInt32BE();\n    const ord = nextByte.toString().charCodeAt(0);\n    if (ord === 0) {\n      // Read the sequence and its properties\n      read(1); // isCircular\n\n      const size = blockSize - 1;\n      if (size < 0) throw new Error(\"Failed parsing SnapGene: < 0 length sequence\");\n      seq.seq = readEnc(size, \"ascii\");\n    } else if (ord === 10) {\n      // Read all the features\n\n      const xml = readEnc(blockSize, \"utf8\") as string;\n      const b = await new Promise((resolve, reject) => {\n        xml2js.parseString(xml, (err, result) => {\n          if (err) reject(err);\n          resolve(result);\n        });\n      });\n\n      const { Features: { Feature = [] } = {} } = b as { Features: { Feature: any[] } };\n      Feature.forEach(({ $: attrs, Segment = [] }) => {\n        let minStart = 0;\n        let maxEnd = 0;\n        if (Segment) {\n          Segment.forEach(({ $: seg }) => {\n            if (!seg) throw new Error(\"Invalid feature definition\");\n            const { range } = seg as { range: string };\n            const [start, end] = range.split(\"-\");\n            minStart = minStart === 0 ? +start : Math.min(minStart, +start);\n            maxEnd = Math.max(maxEnd, +end);\n          });\n        }\n\n        // create an Annotation\n        seq.annotations.push({\n          direction: parseDirection(\n            {\n              \"0\": \"NONE\",\n              \"1\": 1,\n              \"2\": -1,\n              \"3\": \"BIDIRECTIONAL\",\n              undefined: \"NONE\",\n            }[attrs.directionality]\n          ),\n          end: maxEnd - 1,\n          name: attrs.name,\n          start: minStart - 1,\n          type: attrs.type,\n        });\n      });\n    } else {\n      // UNKNOWN: WE IGNORE THE WHOLE BLOCK\n      read(blockSize);\n    }\n  }\n\n  return [\n    {\n      ...seq,\n      // snapgene uses the filename as the sequence name\n      name: fileName.split(sep).pop()?.replace(\".dna\", \"\") || fileName,\n      type: guessType(seq.seq),\n    },\n  ];\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","#!/usr/bin/env node\nimport { existsSync, readFileSync } from \"fs\";\nimport pino from \"pino\";\nimport pretty from \"pino-pretty\";\n\nimport seqparse, { ParseOptions } from \".\";\n\n/** use LOG_LEVEL=debug for some debugging help */\nconst stream = pretty({\n  colorize: true,\n});\nlet logger = pino(\n  {\n    level: process.env.LOG_LEVEL || \"info\",\n  },\n  stream\n);\n\n/** bail, log an example */\nconst exit = () => {\n  console.error(`# Example USAGE:\n\n# parse a file\nseqparse gene.fa\n\n# parse a file from stdin\ncat gene.fa | seqparse\n\n# fetch and parse a file from NCBI of iGEM by accession\nseqparse FJ172221`);\n  process.exit(1);\n};\n\n/** input can be a file name as first arg or stdin */\nconst parseOptions = {} as ParseOptions;\n\nlet input: string | null = null;\nif (process.argv[2]) {\n  input = process.argv[2];\n  logger = logger.child({ arg: true });\n  logger.debug(null, \"reading from arg\");\n} else {\n  logger = logger.child({ stdin: true });\n  try {\n    logger.debug(null, \"attempting to read stdin\");\n    parseOptions.source = readFileSync(process.stdin.fd);\n    parseOptions.fileName = \"Unknown\";\n    input = (parseOptions.source as Buffer).toString(\"utf-8\");\n    logger.debug(null, \"successfully read stdin\");\n  } catch (err) {\n    // only a debug here because am assuming the user just didn't pass anything\n    logger.debug({ err }, \"failed to read stdin\");\n    exit();\n  }\n}\n\n/** throw, no input detected */\nif (!input || !input.length) {\n  logger.error(null, \"no input detected\");\n  exit();\n  process.exit(1);\n}\n\n/** check if file, if so, read */\nconst isFile = existsSync(input);\nlogger = logger.child({ isFile });\n\nlet fileContents: string | null = null;\nif (isFile) {\n  logger = logger.child({ fileName: input });\n  parseOptions.fileName = input;\n  try {\n    logger.debug(null, \"attempting to read file\");\n    parseOptions.source = readFileSync(input);\n    fileContents = (parseOptions.source as Buffer).toString(\"utf-8\");\n    logger = logger.child({ length: fileContents.length, prefix: fileContents.substring(0, 50) });\n    logger.debug(null, \"successfully read file\");\n  } catch (err) {\n    logger.error({ err }, \"failed to read file\");\n    exit();\n  }\n}\n\n/** parse, write to stdout */\nlogger.debug(null, \"attempting to parse input\");\nseqparse(fileContents || input, parseOptions)\n  .then(r => {\n    logger.debug(null, \"successfully parsed file\");\n    console.log(JSON.stringify(r, null, 2));\n  })\n  .catch(err => {\n    logger.error({ err }, \"failed to parse input\");\n    exit();\n  });\n"],"names":[],"sourceRoot":""}